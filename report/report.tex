\documentclass[a4paper, smallheadings,english]{scrartcl}

% enable mutated vowls
\usepackage[utf8]{inputenc}

% vector fonts
\usepackage[T1]{fontenc}
% }}}

% {{{ include packages: math, url, fancyhdr
% break up syllables
\usepackage[english,ngerman]{babel}

% add notes to the doc
%\usepackage{marginnote}

% use math
\usepackage{amsmath, amssymb, amsfonts}

% add graphics
\usepackage{lscape, tikz, graphicx}
\usetikzlibrary{backgrounds}

% display urls, code
\usepackage{url, listings}
\lstset{breaklines,commentstyle=\small\ttfamily,basicstyle=\scriptsize\ttfamily}

% enable custom headings
\usepackage{fancyhdr,lastpage,enumerate}
\renewcommand{\labelenumi}{(\roman{enumi})}
% }}}

%{{{ custom headings
%\pagestyle{plain}
% how do I refer to the author, chapter, etc?

\pagestyle{fancy}
\fancyhead[LO]{\Title} %Kopfzeile links
\fancyhead[LE]{\leftmark\rightmark} %Kopfzeile links
\fancyhead[R]{\Author} %Kopfzeile rechts
\fancyfoot[C]{\footnotesize \thepage\ of \pageref{LastPage}}
\fancypagestyle{firststyle}
{
    \renewcommand{\headrulewidth}{0pt}
    \fancyhf{}
    \fancyfoot[C]{\footnotesize \thepage\ of \pageref{LastPage}}
}
% }}}

\newcommand{\Author}{Jiannan Guo - ICT-Innovation\\Niklas Semmler - ICT-Innovation}
\newcommand{\Title}{Network Management Project}
\newcommand{\note}[1]{\marginnote{\textit{\textbf{#1}} }}
\newcommand{\corr}[2]{\marginnote{\textcolor{red}{#1} }}

\begin{document}
% {{{ Header
\title{\Title}
\author{\Author}
\date{\today}
\maketitle
% }}}
\thispagestyle{firststyle}
\section{Task}
\subsection{Pseudocode}
\begin{lstlisting}[caption={inspired by \cite{stadler2012protocols}}, numbers=left, frame=single]
messages:
(ResponseTimeArriveMessage, responseTime)
(UpdateVector, neighbor)
(TimeOut, responseTime)

objects and help functions:
A       # storing values for and performing aggregation
Comm    # communication messages
A.aggregate_local       # aggregate local response times for local statistics
A.aggregate_sub_tree    # combine local values with children's for statistics
                        #  of the whole subtree
A.value                 # values of statistics of subtree (including own)
Comm.send_to_self       # send a message to the own node with a delay
Comm.send_to_neighbors  # send to all specified neighbors
Comm.send_to_parent     # send to parent
find_parent             # among neighbors, choose first with minimum level as
                        #  new parent

procedure GAP( )
    DELAY = # fixed time window
    Neighbors := empty;
    ResponseTimes := empty;

    if v = root then
        level = 0
        parent = 0
    else
        level = INF
        parent = INF
    end if

    A.initiate()
    while true do
        read message;
        switch (message)
            case (ResponseTimeArriveMessage, responseTime)
                ResponseTimes.add(responseTime)
                # to keep only a set of responseTimes in cache
                Comm.send_to_self(DELAY, TimeOut(responseTime))
                A.aggregate_local(ResponseTimes)
                A.aggregate_sub_tree(Neighbors)
            case (UpdateVector, neighbor):
                Neighbors.add(neighbor) 
                (newParent, newLevel) = find_new_parent(Neighbors)
                A.aggregate_sub_tree(Neighbors)
                if level != newLevel then
                    level = newLevel
                    parent = newParent
                    Comm.send_to_neighbors(Neighbors, level, parent, A.value())
                    continue
                end if
            # to keep only a set of responseTimes in cache
            case (TimeOut, responseTime):
                responses.remove(responseTime)
                A.aggregate_local_value(ResponseTimes)
                A.aggregate_sub_tree(Neighbors)
        end switch
        Comm.send_to_parent(Neighbors, A.value)
    end while
    end procedure
\end{lstlisting}
\subsection{Implementation Details}
A new base class was implemented which all of the tasks extend: \texttt{peersim.EP2300.vector.GAPNode}. In \texttt{peersim.EP2300.message} three new messages were introduced: \texttt{ResponseTimeArriveMessage}, \texttt{UpdateVector}, \texttt{TimeOut}. The first two roughly equal \texttt{LOCALVAR} and \texttt{UPDATE} from the original technical report (see \cite{stadler2012protocols}).

Each node stores all its information on it's neighbors as \texttt{NodeStateVector} in a SortMap named \texttt{neighborList}. Details on the nodes response times are stored in the ArrayList \texttt{requestList}. To focus only on the response times in the current time window, every response time is assigned a time out.

For the implementation with rate control, every message send to the parent will trigger a decrease of the msg budget. As soon as the msg budget is lower or equal to 0, no more messages are sent out. The message budget is reset via a new control \texttt{peersim.EP2300.control.ResetMsgBudget}.
\subsection{Results}
\begin{enumerate}
    \item time series of f(t) and f(t) for r = \{0.2,0.4,0.8\} and \{R1\} from the first 5 minutes
    \item time series of f(t) and f(t) for r = \{0.2,0.4,0.8\} and \{R1\} after the first 5 minutes
    \item trade-off plots for both \{R1,R2\} (and all rate options?? 0.1,0.2,0.4,0.8,1.6)
    \item density plots for r = \{0.2, 0.4, 0.8\} and \{R1,R2\}
\end{enumerate}

\section*{Task 2}
\begin{lstlisting}[caption={inspired by \cite{stadler2012protocols}}, numbers=left, frame=single]
messages:
(ResponseTimeArriveMessage, responseTime)
(UpdateVector, neighbor)
(TimeOut, responseTime)

objects and help functions:
A       # storing values for and performing aggregation
Comm    # communication messages
A.aggregate_local       # aggregate local response times for local statistics
A.aggregate_sub_tree    # combine local values with children's for statistics
                        #  of the whole subtree
A.value                 # values of statistics of subtree (including own)
Comm.send_to_self       # send a message to the own node with a delay
Comm.send_to_neighbors  # send to all specified neighbors
Comm.send_to_parent     # send to parent
find_parent             # among neighbors, choose first with minimum level as
                        #  new parent

procedure GAP( )
    DELAY = # fixed time window
    Neighbors := empty;
    ResponseTimes := empty;

    if v = root then
        level = 0
        parent = 0
    else
        level = INF
        parent = INF
    end if

    A.initiate()
    while true do
        read message;
        switch (message)
            case (ResponseTimeArriveMessage, responseTime)
                ResponseTimes.add(responseTime)
                # to keep only a set of responseTimes in cache
                Comm.send_to_self(DELAY, TimeOut(responseTime))
                A.aggregate_local(ResponseTimes)
                A.aggregate_sub_tree(Neighbors)
            case (UpdateVector, neighbor):
                Neighbors.add(neighbor) 
                (newParent, newLevel) = find_new_parent(Neighbors)
                A.aggregate_sub_tree(Neighbors)
                if level != newLevel then
                    level = newLevel
                    parent = newParent
                    Comm.send_to_neighbors(Neighbors, level, parent, A.value())
                    continue
                end if
            # to keep only a set of responseTimes in cache
            case (TimeOut, responseTime):
                responses.remove(responseTime)
                A.aggregate_local_value(ResponseTimes)
                A.aggregate_sub_tree(Neighbors)
        end switch
        Comm.send_to_parent(Neighbors, A.value)
    end while
    end procedure
\end{lstlisting}

\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.7]{plots/time_series}
    \end{center}
    \caption{Time series plot}
    \label{fig:ts}
\end{figure}
\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.7]{plots/trade_off}
    \end{center}
    \caption{Trade off plot}
    \label{fig:to}
\end{figure}
\begin{figure}[h!]
    \begin{center}
        \includegraphics[scale=0.7]{plots/pdf_of_error}
    \end{center}
    \caption{PDF plot}
    \label{fig:pdf}
\end{figure}

\begin{itemize}
    \item compare performance for $R_1, R_2$
    \begin{itemize}
        \item time series of f~(t) and f(t) for r = \{ 0.2, 0.4, 0.8 \} amd \{$R_1$, $R_2$\} from the first 5 min
        \item trade off plot for $R_1, R_2$
        \item density plot for r = \{ 0.2, 0.4, 0.8 \} and \{$R_1$, $R_2$\}
    \end{itemize}
\end{itemize}

\section{Task II}
\begin{itemize}
    \item pseudo code!
    \item implementation details
    \item compare performance for $R_1, R_2$
    \begin{itemize}
        \item time series of f~(t) and f(t) for r = \{ 0.2, 0.1, 0.05, 0.025, \} amd \{$R_1$, $R_2$\} from the first 5 min
        \item trade off plot for $R_1, R_2$
        \item density plot for r = \{ 0.1, 0.05, 0.025 \} and \{$R_1$, $R_2$\}
    \end{itemize}
\end{itemize}

\section{Task III}
\begin{itemize}
    \item pseudo code!
    \item implementation details
    \item compare performance for $R_1, R_2$
    \begin{itemize}
        \item time series of f~(t) and f(t) for r = \{ 0.2, 0.1, 0.05, 0.025, \} amd \{$R_1$, $R_2$\} from the first 5 min
        \item trade off plot for $R_1, R_2$
        \item density plot for r = \{ 0.1, 0.05, 0.025 \} and \{$R_1$, $R_2$\}
    \end{itemize}
\end{itemize}

\section{Summary}
\begin{itemize}
    \item Compare TaskI, II, III
    \item Compare $R_1, R_2$ globally
\end{itemize}
\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
